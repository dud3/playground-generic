"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFiles = exports.parseFile = exports.parseModule = exports.parseModuleDocumentation = exports.parseClasses = exports.getConstructorDeclarationSignature = exports.parseExports = exports.parseConstants = exports.parseTypeAliases = exports.parseFunctions = exports.parseInterfaces = exports.parseComment = exports.getCommentInfo = exports.addFileToProject = exports.stripImportTypes = void 0;
/**
 * @since 0.6.0
 */
var Apply = require("fp-ts/Apply");
var E = require("fp-ts/Either");
var M = require("fp-ts/Monoid");
var O = require("fp-ts/Option");
var Ord = require("fp-ts/Ord");
var RA = require("fp-ts/ReadonlyArray");
var RE = require("fp-ts/ReaderEither");
var RTE = require("fp-ts/ReaderTaskEither");
var RNEA = require("fp-ts/ReadonlyNonEmptyArray");
var RR = require("fp-ts/ReadonlyRecord");
var S = require("fp-ts/Semigroup");
var function_1 = require("fp-ts/function");
var ast = require("ts-morph");
var doctrine = require("doctrine");
var Path = require("path");
var Module_1 = require("./Module");
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
var CommentInfo = function (description, since, deprecated, examples, category) { return ({
    description: description,
    since: since,
    deprecated: deprecated,
    examples: examples,
    category: category
}); };
// -------------------------------------------------------------------------------------
// parsers
// -------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
var semigroupError = function_1.pipe(S.semigroupString, S.getIntercalateSemigroup('\n'));
var applicativeParser = RE.getReaderValidation(semigroupError);
var sequenceS = Apply.sequenceS(applicativeParser);
var traverse = RA.traverse(applicativeParser);
var every = function (predicates) {
    return M.fold(M.getFunctionMonoid(M.monoidAll)())(predicates);
};
var some = function (predicates) {
    return M.fold(M.getFunctionMonoid(M.monoidAny)())(predicates);
};
var ordByName = function_1.pipe(Ord.ordString, Ord.contramap(function (_a) {
    var name = _a.name;
    return name;
}));
var sortModules = RA.sort(Module_1.ordModule);
var isNonEmptyString = function (s) { return s.length > 0; };
/**
 * @internal
 */
var stripImportTypes = function (s) { return s.replace(/import\("((?!").)*"\)./g, ''); };
exports.stripImportTypes = stripImportTypes;
var getJSDocText = RA.foldRight(function () { return ''; }, function (_, last) { return last.getText(); });
var shouldIgnore = some([
    function (comment) { return function_1.pipe(comment.tags, RR.lookup('internal'), O.isSome); },
    function (comment) { return function_1.pipe(comment.tags, RR.lookup('ignore'), O.isSome); }
]);
var isVariableDeclarationList = function (u) { return u.getKind() === ast.ts.SyntaxKind.VariableDeclarationList; };
var isVariableStatement = function (u) { return u.getKind() === ast.ts.SyntaxKind.VariableStatement; };
/**
 * @internal
 */
var addFileToProject = function (file) { return function (project) { return project.addSourceFileAtPath(file.path); }; };
exports.addFileToProject = addFileToProject;
// -------------------------------------------------------------------------------------
// comments
// -------------------------------------------------------------------------------------
var getSinceTag = function (name, comment) {
    return function_1.pipe(RE.ask(), RE.chainEitherK(function (env) {
        return function_1.pipe(comment.tags, RR.lookup('since'), O.chain(RNEA.head), O.fold(function () {
            return env.settings.enforceVersion
                ? E.left("Missing @since tag in " + env.path.join('/') + "#" + name + " documentation")
                : E.right(O.none);
        }, function (since) { return E.right(O.some(since)); }));
    }));
};
var getCategoryTag = function (name, comment) {
    return function_1.pipe(RE.ask(), RE.chainEitherK(function (env) {
        return function_1.pipe(comment.tags, RR.lookup('category'), O.chain(RNEA.head), E.fromPredicate(function_1.not(every([O.isNone, function () { return RR.hasOwnProperty('category', comment.tags); }])), function () { return "Missing @category value in " + env.path.join('/') + "#" + name + " documentation"; }));
    }));
};
var getDescription = function (name, comment) {
    return function_1.pipe(RE.ask(), RE.chainEitherK(function (env) {
        return function_1.pipe(comment.description, O.fold(function () {
            return env.settings.enforceDescriptions
                ? E.left("Missing description in " + env.path.join('/') + "#" + name + " documentation")
                : E.right(O.none);
        }, function (description) { return E.right(O.some(description)); }));
    }));
};
var getExamples = function (name, comment, isModule) {
    return function_1.pipe(RE.ask(), RE.chainEitherK(function (env) {
        return function_1.pipe(comment.tags, RR.lookup('example'), O.map(RA.compact), O.fold(function () {
            return M.fold(M.monoidAll)([env.settings.enforceExamples, !isModule])
                ? E.left("Missing examples in " + env.path.join('/') + "#" + name + " documentation")
                : E.right(RA.empty);
        }, function (examples) {
            return M.fold(M.monoidAll)([env.settings.enforceExamples, RA.isEmpty(examples), !isModule])
                ? E.left("Missing examples in " + env.path.join('/') + "#" + name + " documentation")
                : E.right(examples);
        }));
    }));
};
/**
 * @internal
 */
var getCommentInfo = function (name, isModule) {
    if (isModule === void 0) { isModule = false; }
    return function (text) {
        return function_1.pipe(RE.right(exports.parseComment(text)), RE.bindTo('comment'), RE.bind('since', function (_a) {
            var comment = _a.comment;
            return getSinceTag(name, comment);
        }), RE.bind('category', function (_a) {
            var comment = _a.comment;
            return getCategoryTag(name, comment);
        }), RE.bind('description', function (_a) {
            var comment = _a.comment;
            return getDescription(name, comment);
        }), RE.bind('examples', function (_a) {
            var comment = _a.comment;
            return getExamples(name, comment, isModule);
        }), RE.bind('deprecated', function (_a) {
            var comment = _a.comment;
            return RE.right(function_1.pipe(comment.tags, RR.lookup('deprecated'), O.isSome));
        }), RE.map(function (_a) {
            var category = _a.category, deprecated = _a.deprecated, description = _a.description, examples = _a.examples, since = _a.since;
            return CommentInfo(description, since, deprecated, examples, category);
        }));
    };
};
exports.getCommentInfo = getCommentInfo;
/**
 * @internal
 */
var parseComment = function (text) {
    var annotation = doctrine.parse(text, { unwrap: true });
    var tags = function_1.pipe(annotation.tags, RNEA.groupBy(function (tag) { return tag.title; }), RR.map(RNEA.map(function (tag) { return function_1.pipe(O.fromNullable(tag.description), O.filter(isNonEmptyString)); })));
    var description = function_1.pipe(O.fromNullable(annotation.description), O.filter(isNonEmptyString));
    return { description: description, tags: tags };
};
exports.parseComment = parseComment;
// -------------------------------------------------------------------------------------
// interfaces
// -------------------------------------------------------------------------------------
var parseInterfaceDeclaration = function (id) {
    return function_1.pipe(getJSDocText(id.getJsDocs()), exports.getCommentInfo(id.getName()), RE.map(function (info) {
        return Module_1.Interface(Module_1.Documentable(id.getName(), info.description, info.since, info.deprecated, info.examples, info.category), id.getText());
    }));
};
/**
 * @category parsers
 * @since 0.6.0
 */
exports.parseInterfaces = function_1.pipe(RE.asks(function (env) {
    return env.sourceFile.getInterfaces().filter(function (id) { return id.isExported(); });
}), RE.chain(function_1.flow(traverse(parseInterfaceDeclaration), RE.map(RA.sort(ordByName)))));
// -------------------------------------------------------------------------------------
// functions
// -------------------------------------------------------------------------------------
var getFunctionDeclarationSignature = function (f) {
    var text = f.getText();
    return function_1.pipe(O.fromNullable(f.compilerNode.body), O.fold(function () { return text.replace('export function ', 'export declare function '); }, function (body) {
        var end = body.getStart() - f.getStart() - 1;
        return text.substring(0, end).replace('export function ', 'export declare function ');
    }));
};
var getFunctionDeclarationJSDocs = function (fd) {
    return function_1.pipe(fd.getOverloads(), RA.foldLeft(function () { return fd.getJsDocs(); }, function (firstOverload) { return firstOverload.getJsDocs(); }));
};
var parseFunctionDeclaration = function (fd) {
    return function_1.pipe(RE.ask(), RE.chain(function (env) {
        return function_1.pipe(O.fromNullable(fd.getName()), O.chain(O.fromPredicate(function (name) { return name.length > 0; })), RE.fromOption(function () { return "Missing function name in module " + env.path.join('/'); }));
    }), RE.chain(function (name) {
        return function_1.pipe(getJSDocText(getFunctionDeclarationJSDocs(fd)), exports.getCommentInfo(name), RE.map(function (info) {
            var signatures = function_1.pipe(fd.getOverloads(), RA.foldRight(function () { return RA.of(getFunctionDeclarationSignature(fd)); }, function (init, last) { return RA.snoc(init.map(getFunctionDeclarationSignature), getFunctionDeclarationSignature(last)); }));
            return Module_1.Function(Module_1.Documentable(name, info.description, info.since, info.deprecated, info.examples, info.category), signatures);
        }));
    }));
};
var parseFunctionVariableDeclaration = function (vd) {
    var vs = vd.getParent().getParent();
    var name = vd.getName();
    return function_1.pipe(getJSDocText(vs.getJsDocs()), exports.getCommentInfo(name), RE.map(function (info) {
        var signature = "export declare const " + name + ": " + exports.stripImportTypes(vd.getType().getText(vd));
        return Module_1.Function(Module_1.Documentable(name, info.description, info.since, info.deprecated, info.examples, info.category), RA.of(signature));
    }));
};
var getFunctionDeclarations = RE.asks(function (env) { return ({
    functions: function_1.pipe(env.sourceFile.getFunctions(), RA.filter(every([
        function (fd) { return fd.isExported(); },
        function_1.not(function_1.flow(getFunctionDeclarationJSDocs, getJSDocText, exports.parseComment, shouldIgnore))
    ]))),
    arrows: function_1.pipe(env.sourceFile.getVariableDeclarations(), RA.filter(every([
        function (vd) { return isVariableDeclarationList(vd.getParent()); },
        function (vd) { return isVariableStatement(vd.getParent().getParent()); },
        function (vd) {
            return function_1.pipe(vd.getInitializer(), every([
                function_1.flow(O.fromNullable, O.chain(O.fromPredicate(ast.Node.isFunctionLikeDeclaration)), O.isSome),
                function () {
                    return function_1.pipe(vd.getParent().getParent().getJsDocs(), function_1.not(function_1.flow(getJSDocText, exports.parseComment, shouldIgnore)));
                },
                function () { return vd.getParent().getParent().isExported(); }
            ]));
        }
    ])))
}); });
/**
 * @category parsers
 * @since 0.6.0
 */
exports.parseFunctions = function_1.pipe(getFunctionDeclarations, RE.chain(function (_a) {
    var arrows = _a.arrows, functions = _a.functions;
    return sequenceS({
        functionDeclarations: function_1.pipe(functions, traverse(parseFunctionDeclaration)),
        variableDeclarations: function_1.pipe(arrows, traverse(parseFunctionVariableDeclaration))
    });
}), RE.map(function (_a) {
    var functionDeclarations = _a.functionDeclarations, variableDeclarations = _a.variableDeclarations;
    return RA.getMonoid().concat(functionDeclarations, variableDeclarations);
}));
// -------------------------------------------------------------------------------------
// type aliases
// -------------------------------------------------------------------------------------
var parseTypeAliasDeclaration = function (ta) {
    return function_1.pipe(RE.of(ta.getName()), RE.chain(function (name) {
        return function_1.pipe(getJSDocText(ta.getJsDocs()), exports.getCommentInfo(name), RE.map(function (info) {
            return Module_1.TypeAlias(Module_1.Documentable(name, info.description, info.since, info.deprecated, info.examples, info.category), ta.getText());
        }));
    }));
};
/**
 * @category parsers
 * @since 0.6.0
 */
exports.parseTypeAliases = function_1.pipe(RE.asks(function (env) {
    return function_1.pipe(env.sourceFile.getTypeAliases(), RA.filter(every([
        function (alias) { return alias.isExported(); },
        function (alias) { return function_1.pipe(alias.getJsDocs(), function_1.not(function_1.flow(getJSDocText, exports.parseComment, shouldIgnore))); }
    ])));
}), RE.chain(traverse(parseTypeAliasDeclaration)), RE.map(RA.sort(ordByName)));
// -------------------------------------------------------------------------------------
// constants
// -------------------------------------------------------------------------------------
var parseConstantVariableDeclaration = function (vd) {
    var vs = vd.getParent().getParent();
    var name = vd.getName();
    return function_1.pipe(getJSDocText(vs.getJsDocs()), exports.getCommentInfo(name), RE.map(function (info) {
        var type = exports.stripImportTypes(vd.getType().getText(vd));
        var signature = "export declare const " + name + ": " + type;
        return Module_1.Constant(Module_1.Documentable(name, info.description, info.since, info.deprecated, info.examples, info.category), signature);
    }));
};
/**
 * @category parsers
 * @since 0.6.0
 */
exports.parseConstants = function_1.pipe(RE.asks(function (env) {
    return function_1.pipe(env.sourceFile.getVariableDeclarations(), RA.filter(every([
        function (vd) { return isVariableDeclarationList(vd.getParent()); },
        function (vd) { return isVariableStatement(vd.getParent().getParent()); },
        function (vd) {
            return function_1.pipe(vd.getInitializer(), every([
                function_1.flow(O.fromNullable, O.chain(O.fromPredicate(function_1.not(ast.Node.isFunctionLikeDeclaration))), O.isSome),
                function () {
                    return function_1.pipe(vd.getParent().getParent().getJsDocs(), function_1.not(function_1.flow(getJSDocText, exports.parseComment, shouldIgnore)));
                },
                function () { return vd.getParent().getParent().isExported(); }
            ]));
        }
    ])));
}), RE.chain(traverse(parseConstantVariableDeclaration)));
// -------------------------------------------------------------------------------------
// exports
// -------------------------------------------------------------------------------------
var parseExportSpecifier = function (es) {
    return function_1.pipe(RE.ask(), RE.chain(function (env) {
        return function_1.pipe(RE.of(es.compilerNode.name.text), RE.bindTo('name'), RE.bind('type', function () { return RE.of(exports.stripImportTypes(es.getType().getText(es))); }), RE.bind('signature', function (_a) {
            var name = _a.name, type = _a.type;
            return RE.of("export declare const " + name + ": " + type);
        }), RE.chain(function (_a) {
            var name = _a.name, signature = _a.signature;
            return function_1.pipe(es.getLeadingCommentRanges(), RA.head, RE.fromOption(function () { return "Missing " + name + " documentation in " + env.path.join('/'); }), RE.chain(function (commentRange) { return function_1.pipe(commentRange.getText(), exports.getCommentInfo(name)); }), RE.map(function (info) {
                return Module_1.Export(Module_1.Documentable(name, info.description, info.since, info.deprecated, info.examples, info.category), signature);
            }));
        }));
    }));
};
var parseExportDeclaration = function (ed) {
    return function_1.pipe(ed.getNamedExports(), traverse(parseExportSpecifier));
};
/**
 * @category parsers
 * @since 0.6.0
 */
exports.parseExports = function_1.pipe(RE.asks(function (env) { return env.sourceFile.getExportDeclarations(); }), RE.chain(traverse(parseExportDeclaration)), RE.map(RA.flatten));
// -------------------------------------------------------------------------------------
// classes
// -------------------------------------------------------------------------------------
var getTypeParameters = function (tps) {
    return tps.length === 0 ? '' : "<" + tps.map(function (p) { return p.getName(); }).join(', ') + ">";
};
var getMethodSignature = function (md) {
    return function_1.pipe(O.fromNullable(md.compilerNode.body), O.fold(function () { return md.getText(); }, function (body) {
        var end = body.getStart() - md.getStart() - 1;
        return md.getText().substring(0, end);
    }));
};
var parseMethod = function (md) {
    return function_1.pipe(RE.of(md.getName()), RE.bindTo('name'), RE.bind('overloads', function () { return RE.of(md.getOverloads()); }), RE.bind('jsdocs', function (_a) {
        var overloads = _a.overloads;
        return RE.of(function_1.pipe(overloads, RA.foldLeft(function () { return md.getJsDocs(); }, function (x) { return x.getJsDocs(); })));
    }), RE.chain(function (_a) {
        var jsdocs = _a.jsdocs, overloads = _a.overloads, name = _a.name;
        return shouldIgnore(exports.parseComment(getJSDocText(jsdocs)))
            ? RE.right(O.none)
            : function_1.pipe(getJSDocText(jsdocs), exports.getCommentInfo(name), RE.map(function (info) {
                var signatures = function_1.pipe(overloads, RA.foldRight(function () { return RA.of(getMethodSignature(md)); }, function (init, last) {
                    return RA.snoc(init.map(function (md) { return md.getText(); }), getMethodSignature(last));
                }));
                return O.some(Module_1.Method(Module_1.Documentable(name, info.description, info.since, info.deprecated, info.examples, info.category), signatures));
            }));
    }));
};
var parseProperty = function (classname) { return function (pd) {
    var name = pd.getName();
    return function_1.pipe(getJSDocText(pd.getJsDocs()), exports.getCommentInfo(classname + "#" + name), RE.map(function (info) {
        var type = exports.stripImportTypes(pd.getType().getText(pd));
        var readonly = function_1.pipe(O.fromNullable(pd.getFirstModifierByKind(ast.ts.SyntaxKind.ReadonlyKeyword)), O.fold(function () { return ''; }, function () { return 'readonly '; }));
        var signature = "" + readonly + name + ": " + type;
        return Module_1.Property(Module_1.Documentable(name, info.description, info.since, info.deprecated, info.examples, info.category), signature);
    }));
}; };
var parseProperties = function (name, c) {
    return function_1.pipe(c.getProperties(), 
    // take public, instance properties
    RA.filter(every([
        function (prop) { return !prop.isStatic(); },
        function (prop) { return function_1.pipe(prop.getFirstModifierByKind(ast.ts.SyntaxKind.PrivateKeyword), O.fromNullable, O.isNone); },
        function (prop) { return function_1.pipe(prop.getJsDocs(), function_1.not(function_1.flow(getJSDocText, exports.parseComment, shouldIgnore))); }
    ])), traverse(parseProperty(name)));
};
/**
 * @internal
 */
var getConstructorDeclarationSignature = function (c) {
    return function_1.pipe(O.fromNullable(c.compilerNode.body), O.fold(function () { return c.getText(); }, function (body) {
        var end = body.getStart() - c.getStart() - 1;
        return c.getText().substring(0, end);
    }));
};
exports.getConstructorDeclarationSignature = getConstructorDeclarationSignature;
var getClassName = function (c) {
    return function_1.pipe(RE.ask(), RE.chain(function (env) {
        return function_1.pipe(O.fromNullable(c.getName()), RE.fromOption(function () { return "Missing class name in module " + env.path.join('/'); }));
    }));
};
var getClassCommentInfo = function (name, c) {
    return function_1.pipe(c.getJsDocs(), getJSDocText, exports.getCommentInfo(name));
};
var getClassDeclarationSignature = function (name, c) {
    return function_1.pipe(RE.ask(), RE.map(function () { return getTypeParameters(c.getTypeParameters()); }), RE.map(function (typeParameters) {
        return function_1.pipe(c.getConstructors(), RA.foldLeft(function () { return "export declare class " + name + typeParameters; }, function (head) { return "export declare class " + name + typeParameters + " { " + exports.getConstructorDeclarationSignature(head) + " }"; }));
    }));
};
var parseClass = function (c) {
    return function_1.pipe(getClassName(c), RE.bindTo('name'), RE.bind('info', function (_a) {
        var name = _a.name;
        return getClassCommentInfo(name, c);
    }), RE.bind('signature', function (_a) {
        var name = _a.name;
        return getClassDeclarationSignature(name, c);
    }), RE.bind('methods', function () { return function_1.pipe(c.getInstanceMethods(), traverse(parseMethod), RE.map(RA.compact)); }), RE.bind('staticMethods', function () { return function_1.pipe(c.getStaticMethods(), traverse(parseMethod), RE.map(RA.compact)); }), RE.bind('properties', function (_a) {
        var name = _a.name;
        return parseProperties(name, c);
    }), RE.map(function (_a) {
        var methods = _a.methods, staticMethods = _a.staticMethods, properties = _a.properties, info = _a.info, name = _a.name, signature = _a.signature;
        return Module_1.Class(Module_1.Documentable(name, info.description, info.since, info.deprecated, info.examples, info.category), signature, methods, staticMethods, properties);
    }));
};
var getClasses = RE.asks(function (env) {
    return function_1.pipe(env.sourceFile.getClasses(), RA.filter(function (c) { return c.isExported(); }));
});
/**
 * @category parsers
 * @since 0.6.0
 */
exports.parseClasses = function_1.pipe(getClasses, RE.chain(traverse(parseClass)), RE.map(RA.sort(ordByName)));
// -------------------------------------------------------------------------------------
// modules
// -------------------------------------------------------------------------------------
var getModuleName = function (path) { return Path.parse(RNEA.last(path)).name; };
/**
 * @internal
 */
exports.parseModuleDocumentation = function_1.pipe(RE.ask(), RE.chainEitherK(function (env) {
    var name = getModuleName(env.path);
    // If any of the settings enforcing documentation are set to `true`, then
    // a module should have associated documentation
    var isDocumentationRequired = M.fold(M.monoidAny)([env.settings.enforceDescriptions, env.settings.enforceVersion]);
    var onMissingDocumentation = function () {
        return isDocumentationRequired
            ? E.left("Missing documentation in " + env.path.join('/') + " module")
            : E.right(Module_1.Documentable(name, O.none, O.none, false, RA.empty, O.none));
    };
    return function_1.pipe(env.sourceFile.getStatements(), RA.foldLeft(onMissingDocumentation, function (statement) {
        return function_1.pipe(statement.getLeadingCommentRanges(), RA.foldLeft(onMissingDocumentation, function (commentRange) {
            return function_1.pipe(exports.getCommentInfo(name, true)(commentRange.getText())(env), E.map(function (info) {
                return Module_1.Documentable(name, info.description, info.since, info.deprecated, info.examples, info.category);
            }));
        }));
    }));
}));
/**
 * @category parsers
 * @since 0.6.0
 */
exports.parseModule = function_1.pipe(RE.ask(), RE.chain(function (env) {
    return function_1.pipe(exports.parseModuleDocumentation, RE.bindTo('documentation'), RE.bind('interfaces', function () { return exports.parseInterfaces; }), RE.bind('functions', function () { return exports.parseFunctions; }), RE.bind('typeAliases', function () { return exports.parseTypeAliases; }), RE.bind('classes', function () { return exports.parseClasses; }), RE.bind('constants', function () { return exports.parseConstants; }), RE.bind('exports', function () { return exports.parseExports; }), RE.map(function (_a) {
        var documentation = _a.documentation, classes = _a.classes, interfaces = _a.interfaces, functions = _a.functions, typeAliases = _a.typeAliases, constants = _a.constants, exports = _a.exports;
        return Module_1.Module(documentation, env.path, classes, interfaces, functions, typeAliases, constants, exports);
    }));
}));
// -------------------------------------------------------------------------------------
// files
// -------------------------------------------------------------------------------------
/**
 * @internal
 */
var parseFile = function (project) { return function (file) {
    return function_1.pipe(RTE.ask(), RTE.chain(function (env) {
        return function_1.pipe(RTE.right(file.path.split(Path.sep)), RTE.bindTo('path'), RTE.bind('sourceFile', function () {
            return function_1.pipe(O.fromNullable(project.getSourceFile(file.path)), RTE.fromOption(function () { return "Unable to locate file: " + file.path; }));
        }), RTE.chainEitherK(function (menv) { return exports.parseModule(__assign(__assign({}, env), menv)); }));
    }));
}; };
exports.parseFile = parseFile;
var createProject = function (files) {
    return function_1.pipe(RTE.ask(), RTE.chainFirst(function (_a) {
        var ast = _a.ast;
        return RTE.of(function_1.pipe(files, RA.map(function (file) { return ast.addFile(file)(ast.project); })));
    }), RTE.map(function (_a) {
        var ast = _a.ast;
        return ast.project;
    }));
};
/**
 * @category parsers
 * @since 0.6.0
 */
var parseFiles = function (files) {
    return function_1.pipe(createProject(files), RTE.chain(function (project) { return function_1.pipe(files, RA.traverse(RTE.getReaderTaskValidation(semigroupError))(exports.parseFile(project))); }), RTE.map(function_1.flow(RA.filter(function (module) { return !module.deprecated; }), sortModules)));
};
exports.parseFiles = parseFiles;
