/**
 * @since 0.3.0
 */
import { Contravariant1 } from 'fp-ts/es6/Contravariant'
import { Predicate } from 'fp-ts/es6/function'
import { IO } from 'fp-ts/es6/IO'
import { Monoid } from 'fp-ts/es6/Monoid'
import { URIS3, Kind3, URIS2, Kind2, URIS, Kind, HKT } from 'fp-ts/es6/HKT'
import { MonadIO3, MonadIO2C, MonadIO2, MonadIO1, MonadIO } from 'fp-ts/es6/MonadIO'
declare module 'fp-ts/es6/HKT' {
  interface URItoKind<A> {
    LoggerIO: LoggerIO<A>
  }
}
/**
 * @since 0.3.0
 */
export declare const URI = 'LoggerIO'
/**
 * @since 0.3.0
 */
export declare type URI = typeof URI
/**
 * @since 0.3.0
 */
export interface LoggerIO<A> {
  (a: A): IO<void>
}
/**
 * @since 0.3.0
 */
export declare const filter: <A>(logger: LoggerIO<A>, predicate: Predicate<A>) => LoggerIO<A>
/**
 * @since 0.3.0
 */
export declare const getMonoid: <A = never>() => Monoid<LoggerIO<A>>
/**
 * @since 0.3.0
 */
export declare const loggerIO: Contravariant1<URI>
/**
 * @category Combinator
 *
 * @since 0.3.4
 *
 * @example
 * import { pipe } from 'fp-ts/es6/pipeable'
 * import * as IO from 'fp-ts/es6/IO'
 * import * as C from 'fp-ts/es6/Console'
 * import { withLogger } from 'logging-ts/lib/IO'
 * import { equal } from 'assert'
 *
 * const log = withLogger(IO.io)(C.log)
 *
 * const result = pipe(
 *   IO.of(3),
 *   log(n => `lifted "${n}" to the IO monad`), // n === 3
 *   IO.map(n => n * n),
 *   log(n => `squared the value, which is "${n}"`), // n === 9
 * )
 *
 * equal(result(), 9)
 */
export declare function withLogger<M extends URIS3>(
  M: MonadIO3<M>
): <B>(logger: LoggerIO<B>) => <A>(message: (a: A) => B) => <R, E>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>
export declare function withLogger<M extends URIS2>(
  M: MonadIO2<M>
): <B>(logger: LoggerIO<B>) => <A>(message: (a: A) => B) => <E>(ma: Kind2<M, E, A>) => Kind2<M, E, A>
export declare function withLogger<M extends URIS2, E>(
  M: MonadIO2C<M, E>
): <B>(logger: LoggerIO<B>) => <A>(message: (a: A) => B) => (ma: Kind2<M, E, A>) => Kind2<M, E, A>
export declare function withLogger<M extends URIS>(
  M: MonadIO1<M>
): <B>(logger: LoggerIO<B>) => <A>(message: (a: A) => B) => (ma: Kind<M, A>) => Kind<M, A>
export declare function withLogger<M>(
  M: MonadIO<M>
): <B>(logger: LoggerIO<B>) => <A>(message: (a: A) => B) => (ma: HKT<M, A>) => HKT<M, A>
declare const contramap: <A, B>(f: (b: B) => A) => (fa: LoggerIO<A>) => LoggerIO<B>
export {
  /**
   * @since 0.3.0
   */
  contramap
}
